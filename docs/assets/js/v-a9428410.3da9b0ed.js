"use strict";(self.webpackChunkblogs_gjk=self.webpackChunkblogs_gjk||[]).push([[15],{7515:(n,s,a)=>{a.r(s),a.d(s,{default:()=>p});const e=(0,a(6252).uE)('<h1 id="decorator-装饰器" tabindex="-1"><a class="header-anchor" href="#decorator-装饰器" aria-hidden="true">#</a> Decorator 装饰器</h1><h2 id="类的修饰" tabindex="-1"><a class="header-anchor" href="#类的修饰" aria-hidden="true">#</a> 类的修饰</h2><p>类修饰器一般用来修改、增加类的静态属性，方法,或者添加实例方法,装饰器的参数是这个类构造器</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myTestable</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    target<span class="token punctuation">.</span>isTestable <span class="token operator">=</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span>\n\n@myTestable\n<span class="token keyword">class</span> <span class="token class-name">MyTestableClass</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyTestableClass<span class="token punctuation">.</span>isTestable<span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre></div><p>上面代码中，装饰器 <code>myTestable</code> 可以接受参数，这就等于可以修改装饰器的行为。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myTestable</span><span class="token punctuation">(</span><span class="token parameter">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        target<span class="token punctuation">.</span>isTestable <span class="token operator">=</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n@<span class="token function">myTestable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>\n<span class="token keyword">class</span> <span class="token class-name">MyTestableClass</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyTestableClass<span class="token punctuation">.</span>isTestable<span class="token punctuation">)</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。</p><p>这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p></blockquote><h2 id="装饰-class-的方法" tabindex="-1"><a class="header-anchor" href="#装饰-class-的方法" aria-hidden="true">#</a> 装饰 class 的方法</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">readonly</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// descriptor对象原来的值如下</span>\n    <span class="token comment">// {</span>\n    <span class="token comment">//   value: specifiedFunction,</span>\n    <span class="token comment">//   enumerable: false,</span>\n    <span class="token comment">//   configurable: true,</span>\n    <span class="token comment">//   writable: true</span>\n    <span class="token comment">// };</span>\n    descriptor<span class="token punctuation">.</span>writable <span class="token operator">=</span> <span class="token boolean">false</span>\n    <span class="token keyword">return</span> descriptor\n<span class="token punctuation">}</span>\n\n<span class="token doc-comment comment">/**\n * readonly(MyTestableClass.prototype, &#39;name&#39;, descriptor);\n * 类似于\n * Object.defineProperty(MyTestableClass.prototype, &#39;name&#39;, descriptor);\n **/</span>\n\n<span class="token keyword">class</span> <span class="token class-name">MyTestableClass</span> <span class="token punctuation">{</span>\n    @readonly\n    <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">&#39;Tom&#39;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>装饰器第一个参数是类的原型对象，上例是 <code>MyTestableClass.prototype</code>，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时 target 参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p><p>另外，上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p>',11),p={render:function(n,s){return e}}},8981:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-a9428410",path:"/basic/decorator.html",title:"Decorator 装饰器",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"类的修饰",slug:"类的修饰",children:[]},{level:2,title:"装饰 class 的方法",slug:"装饰-class-的方法",children:[]}],filePathRelative:"basic/decorator.md",git:{updatedTime:1628762435e3,contributors:[{name:"GuoJikun",email:"guojikun@y-open.com",commits:1}]}}}}]);