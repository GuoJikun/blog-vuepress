"use strict";(self.webpackChunkblogs_gjk=self.webpackChunkblogs_gjk||[]).push([[3],{8080:(s,n,a)=>{a.r(n),a.d(n,{default:()=>c});var e=a(6252);const t=(0,e.uE)('<h1 id="ecmascript-2020-es11-新特性简介" tabindex="-1"><a class="header-anchor" href="#ecmascript-2020-es11-新特性简介" aria-hidden="true">#</a> ECMAScript 2020(ES11)新特性简介</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p><code>ES2020</code> 是 ECMA 协会在 2020 年 6 月发行的一个版本，因为是 ECMAScript 的第十一个版本，所以也称为 ES11.</p><p>今天我们讲解一下 ES11 的新特性。</p><p>ES11 引入了 9 个新特性，我们接下来一一讲解。</p><h2 id="动态-imports" tabindex="-1"><a class="header-anchor" href="#动态-imports" aria-hidden="true">#</a> 动态 imports</h2><p>在 ES11 之前，我们可以使用下面的方式进行模块的导入：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> TestModule <span class="token keyword">from</span> <span class="token string">&#39;./test-module.js&#39;</span>\n</code></pre></div><p>导入模块的现有语法形式为静态声明。它们接受字符串字面作为模块标识符，并通过运行前&quot;链接&quot;过程将绑定引入本地范围。可能会导致程序加载速度的降低。而且上面的模块名字是写死的，不可以在程序运行的时候进行动态修改。</p><p>为了解决这个问题，ES11 引入了新的<code>import()</code> 方法，使用这个方法，你可以对模块进行动态导入，并且通过设置模块名为变量的形式，可以对模块名进行动态修改，非常的神奇。我们看一个具体的使用例子：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> baseModulePath <span class="token operator">=</span> <span class="token string">&#39;./baseModules&#39;</span>\n<span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;btn&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> userList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\nbtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> userModule <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>baseModulePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/users.js</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n    userList <span class="token operator">=</span> userModule<span class="token punctuation">.</span><span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>上面代码中我们定义了一个基本的 Module 路径，通过点击页面上的按钮，可以动态的加载一个<code>users.js</code>模块，然后调用该模块的<code>getUserList()</code>方法，获得用户列表。</p><h2 id="import-meta" tabindex="-1"><a class="header-anchor" href="#import-meta" aria-hidden="true">#</a> import.meta</h2><p>除了动态引入模块之外，import 还提供了一个元属性<code>meta</code>,它包含了当前引入的模块的信息，目前他里面有一个 url 属性，代表模块被引用的 URL。如果想使用 URL 信息，那么可以在代码中使用<code>import.meta.url</code>。</p><h2 id="bigint" tabindex="-1"><a class="header-anchor" href="#bigint" aria-hidden="true">#</a> BigInt</h2><p>ES11 引入了新的数据类型<code>BigInt</code>，在这之前，<code>javascript</code>中表示数字的对象是<code>Number</code>，它可以表示<code>64-bit</code>的浮点类型数字。当然它也可以代表整数，但是整数表示的最大值是<code>2^53</code>,也可以用<code>Number.MAX_SAFE_INTEGER</code>来表示。</p><p>一般来说 Number 已经够用了，但是如果在某些情况下需要对 64-bit 的整数进行存储或者运算，或者要表示的范围超过了 64-bit 的话，Number 就不够用了。</p><p>怎么办呢？如果只是存储的话，可以存储为字符串，但是第二种字符串就不适用了。于是引入了 BigInt 来解决这个问题。要表示 BigInt，只需要在数字的后面加上 n 即可。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> bigInt1 <span class="token operator">=</span> <span class="token number">112233445566778899n</span>\n<span class="token keyword">const</span> bigInt2 <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token string">&#39;112233445566778899&#39;</span><span class="token punctuation">)</span>\n</code></pre></div><p>可以使用<code>typeof</code>来查看<code>bigInt</code>的类型。要注意的是虽然<code>Number</code>和<code>BigInt</code>都代表的是数字，但是两者是不能混用的，你不能将一个<code>Number</code>和一个<code>BigInt</code>相加。这会报<code>TypeError</code>异常。</p><p>如果非要进行操作，那么可以使用 BigInt 构造函数将 Number 转换成为 BigInt 之后再进行。</p><h2 id="string-prototype-matchall" tabindex="-1"><a class="header-anchor" href="#string-prototype-matchall" aria-hidden="true">#</a> String.prototype.matchAll()</h2><p><code>matchAll</code>是<code>match</code>的增强版，<code>match</code>返回匹配的结果，<code>matchAll</code>返回更加详细的匹配结果</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">&#39;abcdefga&#39;</span>\n<span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>\n<span class="token keyword">const</span> result1 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>\n<span class="token comment">/*\n * result1\n * [&#39;a&#39;,&#39;a&#39;]\n */</span>\n<span class="token keyword">const</span> result2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>\n<span class="token comment">/*\n * result2\n * [\n *   [ &#39;a&#39;, index: 0, input: &#39;abcdefga&#39;, groups: undefined ],\n *   [ &#39;a&#39;, index: 7, input: &#39;abcdefga&#39;, groups: undefined ]\n * ]\n */</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="globalthis" tabindex="-1"><a class="header-anchor" href="#globalthis" aria-hidden="true">#</a> globalThis</h2><p>对于 javascript 来说，不同的环境对应的全局对象的获取方式也是不同的，对于浏览器来说通常使用的是<code>window</code>，但是在 web worker 中使用的是<code>self</code>，而在 nodejs 中使用的是<code>global</code>。</p><p>为了解决在不同环境中的全局对象不同的问题，<code>ES11</code>引入了<code>globalThis</code>，通过这个全局对象，程序员就不用再去区分到底是在哪个环境下了，只需要使用 globalThis 即可。</p><h2 id="promise-allsettled" tabindex="-1"><a class="header-anchor" href="#promise-allsettled" aria-hidden="true">#</a> Promise.allSettled()</h2><p>自从 Promise 引入之后，有两个方法可以对 Promise 进行组合，分别是<code>Promise.all()</code> 和<code>Promise.race()</code>。</p><ul><li><code>Promise.race()</code>：只要有一个<code>resolve</code>就返回（返回最快执行的那个）</li><li><code>Promise.all()</code>：它会等待所有的<code>Promise</code>都运行完毕之后返回，如果其中有一个<code>Promise</code>被<code>rejected</code>，那么整个<code>Promise.all()</code>都会被<code>rejected</code>。在这种情况下，如果有一个 Promise 被 rejected，其他的 Promise 的结果也都获取不了。</li><li><code>Promise.allSettled()</code>: 这个方法会等待所有的<code>Promise</code>结束，不管他们是否被<code>rejected</code>,所以可以获得所有的结果。</li></ul><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> promises <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;index.html&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://does-not-exist/&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n\n<span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span>\n<span class="token keyword">const</span> errors <span class="token operator">=</span> results<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">&#39;rejected&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>reason<span class="token punctuation">)</span>\n</code></pre></div><h2 id="空值合并运算符" tabindex="-1"><a class="header-anchor" href="#空值合并运算符" aria-hidden="true">#</a> <code>??</code> 空值合并运算符</h2><p><code>??</code>操作符是一个判断是否为空然后赋值的操作，如果没有这个操作符，我们通常使用||来简单的进行这个操作，如下所示：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;Tom&#39;</span><span class="token punctuation">,</span>\n    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> yourAge <span class="token operator">=</span> person<span class="token punctuation">.</span>age <span class="token operator">||</span> <span class="token number">18</span>\n</code></pre></div><p>上面的代码意思是如果<code>person.age</code> 是空，那么就将<code>yourAge</code>设置成为<code>18</code>。</p><p>但是上面代码有个问题，如果 someBody.age=0 的话，上述逻辑也成立。使用<code>??</code>操作符可以解决这个问题。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;Tom&#39;</span><span class="token punctuation">,</span>\n    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> yourAge <span class="token operator">=</span> person<span class="token punctuation">.</span>age <span class="token operator">??</span> <span class="token number">18</span>\n</code></pre></div><h2 id="可选链操作符" tabindex="-1"><a class="header-anchor" href="#可选链操作符" aria-hidden="true">#</a> <code>?.</code> 可选链操作符</h2><p>我们有时候在获取某个对象的属性的时候，需要进行对象的 null 判断，否则从 null 对象中取出属性就会报错，但是通常的?:操作符使用起来太复杂了，如果有多个对象和属性连写的情况下更是如此，如果使用?.操作符就会简单很多：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;Tom&#39;</span><span class="token punctuation">,</span>\n    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> age <span class="token operator">=</span> person<span class="token operator">?.</span>age\n</code></pre></div><p>如上所示，这个一个连写操作，但是使用<code>?.</code>就变得很简单。</p><p>同样<code>?.</code>还可以用在对象的方法上：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;Tom&#39;</span><span class="token punctuation">,</span>\n    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> person<span class="token punctuation">.</span>age\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> age <span class="token operator">=</span> student<span class="token punctuation">.</span>getAge<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>上面代码表示，如果<code>person</code>的<code>getAge</code>方法存在，则调用，否则返回<code>undefined</code>。</p><h2 id="for-in" tabindex="-1"><a class="header-anchor" href="#for-in" aria-hidden="true">#</a> for-in</h2><p>ECMAScript 遗留了 <code>for-in</code> 循环顺序的详尽介绍待填补。在 ES2020 中为 <code>for-in</code> 机制定义了一套规则。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',47),p={href:"https://github.com/tc39/proposals/blob/master/finished-proposals.md",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("proposals/finished-proposals.md at master · tc39/proposals (github.com)"),c={render:function(s,n){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[t,(0,e.Wm)("p",null,[(0,e.Wm)("a",p,[o,(0,e.Wm)(a)])])],64)}}},3620:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-0d904aba",path:"/basic/ecma/2020.html",title:"ECMAScript 2020(ES11)新特性简介",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"简介",slug:"简介",children:[]},{level:2,title:"动态 imports",slug:"动态-imports",children:[]},{level:2,title:"import.meta",slug:"import-meta",children:[]},{level:2,title:"BigInt",slug:"bigint",children:[]},{level:2,title:"String.prototype.matchAll()",slug:"string-prototype-matchall",children:[]},{level:2,title:"globalThis",slug:"globalthis",children:[]},{level:2,title:"Promise.allSettled()",slug:"promise-allsettled",children:[]},{level:2,title:"?? 空值合并运算符",slug:"空值合并运算符",children:[]},{level:2,title:"?. 可选链操作符",slug:"可选链操作符",children:[]},{level:2,title:"for-in",slug:"for-in",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],filePathRelative:"basic/ecma/2020.md",git:{updatedTime:1628762435e3,contributors:[{name:"GuoJikun",email:"guojikun@y-open.com",commits:1}]}}}}]);